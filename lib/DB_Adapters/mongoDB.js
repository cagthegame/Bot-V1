/**
</> Original base BochilGaming 
</> Recode simple by @NeKosmic
**/

import mongoose from"mongoose";const{Schema:Schema,connect:connect,model:_model}=mongoose,defaultOptions={useNewUrlParser:!0,useUnifiedTopology:!0};export class mongoDB{constructor(t,s=defaultOptions){this.url=t,this.options=s,this.data=this._data={},this._schema={},this._model={},this.db=connect(this.url,{...this.options}).catch(console.error)}async read(){this.conn=await this.db;let t=this._schema=new Schema({data:{type:Object,required:!0,default:{}}});try{this._model=_model("data",t)}catch{this._model=_model("data")}return this._data=await this._model.findOne({}),this._data?this.data=this._data.data:(this.data={},await this.write(this.data),this._data=await this._model.findOne({})),this.data}write(t){return new Promise((async(s,a)=>t?this._data?void this._model.findById(this._data._id,((i,e)=>i?a(i):(e.data||(e.data={}),e.data=t,this.data={},e.save(s)))):s(new this._model({data:t}).save()):a(t)))}}export const mongoDBV2=class{constructor(t,s=defaultOptions){this.url=t,this.options=s,this.models=[],this.data={},this.lists,this.list,this.db=connect(this.url,{...this.options}).catch(console.error)}async read(){this.conn=await this.db;let t=new Schema({data:[{name:String}]});try{this.list=_model("lists",t)}catch(t){this.list=_model("lists")}this.lists=await this.list.findOne({}),this.lists?.data||(await this.list.create({data:[]}),this.lists=await this.list.findOne({}));const s=[];await Promise.all(this.lists.data.map((async({name:t})=>{let a;try{a=_model(t,new Schema({data:Array}))}catch(i){console.error(i);try{a=_model(t)}catch(a){s.push(t),console.error(a)}}if(a){const s=this.models.findIndex((s=>s.name===t));-1!==s?this.models[s].model=a:this.models.push({name:t,model:a});const i=await a.find({});this.data[t]=Object.fromEntries(i.map((t=>t.data)))}})));try{let t=await this.list.findById(this.lists._id);t.data=t.data.filter((t=>!s.includes(t.name))),await t.save()}catch(t){console.error(t)}return this.data}write(t){return new Promise((async(s,a)=>{if(!this.lists||!t)return a(t||this.lists);const i=Object.keys(t),e=[];await Promise.all(i.map((async s=>{const a=this.models.findIndex((t=>t.name===s));if(-1!==a){const i=this.models[a].model;Object.keys(t[s]).length>0&&(await i.deleteMany().catch(console.error),await i.insertMany(Object.entries(t[s]).map((t=>({data:t}))))),e.push({name:s})}else{const a=new Schema({data:Array});let i;try{i=_model(s,a)}catch(t){console.error(t),i=_model(s)}if(i){const a=this.models.findIndex((t=>t.name===s));-1!==a?this.models[a].model=i:this.models.push({name:s,model:i}),await i.insertMany(Object.entries(t[s]).map((t=>({data:t})))),e.push({name:s})}}}))),this.list.findById(this.lists._id,(async(i,o)=>{if(i)return a(i);o?(o.data=e,await o.save()):(await this.read(),await this.write(t)),this.data={},s()}))}))}};

/**
[_>] https://github.com/NeKosmic/
[_>] https://gitlab.com/NeKosmic/
**/